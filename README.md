# Documentation  

Project description --> describe what the project does

_References_:

[1] 

[2] 

[3] 

## _Installation:_

```sh
pip install PackageName
```

## _Parameters:_

**observation**: numpy.ndarray

Timeseries of observation/truth (1D).

**forecast**: numpy.ndarray

Forecast array (2D) with first dimension equal to the dimension of observation, and second dimension equal to the ensemble size.
    
**climatology**: numpy.ndarray

Climatological array (2D) with first dimension equal to the dimension of observation, and second dimension equal to the number of years considered in climatology.

**event_lbound**: int or float

The lower bound for the event considered. 

E.g. 1: If the event considered is lower tercile, then event_lbound value is 0. 

E.g. 2: If the event considered is upper tercile, then event_lbound value is 2/3. 

_NOTE_: The value should be in the range of 0 to 1.

**event_ubound**: int or float

The upper bound for the event considered.

E.g. 1: If the event considered is lower tercile, then event_ubound value is 1/3.

E.g. 2: If the event considered is upper tercile, then event_ubound value is 1. 

_NOTE_: The value should be in the range of 0 to 1.
            
**closed_ends**: str, optional

The bounds (upper and/or lower) to include in the event formulation. Options: 'left', 'right', 'none', 'both'. 

E.g. 1: If closed_ends = 'left', then the event becomes event_lbound <= event < event_ubound. 

E.g. 2: If closed_ends = 'both', then the event becomes event_lbound <= event <= event_ubound.

_NOTE_: The default value is 'both'. The value is case sensitive.
            
**nbins**: int, optional

Number of bins to stratify the forecasts into. The default is 5.

_NOTE_: The bins are of equal width.
            
**weights**: numpy.ndarray, optional

The weights for the forecast data. It should have the same shape as the forecast data.


## _Method(s):_

**contingency_table()**:

_Returns_:


**confidence_intervals()**:

_Returns_:


**forecast_attributes()**:

_Returns_:


**plot_diagram()**:

_Returns_:


## _Demonstration:_

```python
import ReliabilityDiagram as rd
import numpy as np
import matplotlib.pyplot as pl
```

### Example - 1:
* Create case data
###### Input
```python
nobs = 5000   # number of events
nclim = 30    # number of years considered in climatology
nfc = 51      # ensemble size of the forecasts

clima = np.random.normal(loc=0,scale=10,size=(nobs,nclim))   # climatology (follows the same normal distribution for all events)
obs = np.random.normal(loc=0,scale=10,size=(nobs))           # observations drawn from the same distribution as climatology
fcast = np.random.normal(loc=obs+np.random.normal(loc=2,scale=5,size=(nobs)) ,scale=5,size=(nfc,nobs)).T   # forecasts (also generated by a normal distribution 
                                                                                                           # s.t. ensemble mean = observations + bias + noise)
```
* Compute contingency table and forecast attributes
###### Input
```python
data = rd.ReliabilityDiagram(obs,fcast,clima,0,1/4,closed_ends='both',nbins=10)  # example for lower quartile
```

###### Input
```python
c_table = data.contingency_table()    
print(c_table)
```
###### Output

    array([[  77., 2811.],
           [  86.,  292.],
           [  72.,  184.],
           [  69.,  118.],
           [  79.,   79.],
           [  97.,   60.],
           [ 105.,   47.],
           [ 111.,   33.],
           [ 151.,   20.],
           [ 494.,   15.]])

###### Input
```python
rel, res = data.forecast_attributes()
print(rel, res)
```

###### Output

    Reliability =  0.0004  | Resolution =  0.0116 
    (Reliability - Resolution) =  -0.0112
    0.00040451128009458606 0.011559587280094586
    

* Plot reliability diagram

###### Input
```python
# Compute needed elements for diagram
yi = data.bins  # both have the same bins for the forecast probabilities
oi, ci_low, ci_upp = data.observed_frequency_confidence()
wti = np.sum(c_table,axis=1)/np.sum(c_table) 

# Elements for plot
xd = yd = [0,1]
q = data.ub - data.lb
clim_x = clim_y = [q,q]
sk_line = [q/2,(1-q)/2+q]

# Plot
fig = pl.figure(figsize=(7,5))
pl.plot(xd,yd,color='black',linestyle=':',linewidth=0.5)
pl.plot(xd,clim_y,color='black',linestyle=':',linewidth=0.5)
pl.plot(clim_x,yd,color='black',linestyle=':',linewidth=0.5)
pl.plot(xd,sk_line,color='black',linestyle='--',linewidth=0.5)
pl.fill_between(xd,xd,sk_line,facecolor='grey',alpha=0.2)
pl.fill_betweenx(yd,yd,clim_x,facecolor='grey',alpha=0.2)
pl.scatter(yi,oi,s=wti*10000,color='deepskyblue',marker='o',alpha=0.5,edgecolors='none')
pl.plot(yi,oi,color='deepskyblue',linestyle='-',linewidth=0.8)
pl.errorbar(yi,oi,yerr=[oi - ci_low, ci_upp - oi],ecolor='deepskyblue',elinewidth=0.8,alpha=0.5)
pl.ylim(0.0,1.0)
pl.xlim(0.0,1.0)
pl.ylabel('Observed frequency \np(o|y)',fontsize=11)
pl.xlabel('Forecast probability \ny',fontsize=11)
pl.title("Lower quartile (underforecasting)")
pl.tight_layout()
```


###### Output

![png](example1.png)
    


### Example - 2:

###### Input
```python
fcast2 = np.random.normal(loc=obs+np.random.normal(loc=0,scale=3,size=(nobs)) ,scale=5,size=(nfc,nobs)).T   
```

###### Input
```python
data_lt = rd.ReliabilityDiagram(obs,fcast2,clima,0,1/3,closed_ends='both',nbins=10)  # example for the lower tercile
data_ut = rd.ReliabilityDiagram(obs,fcast2,clima,2/3,1,closed_ends='both',nbins=10)  # example for the upper tercile
# ```

* Plot reliability diagram

###### Input
```python
# Compute needed elements for diagram
c_table_lt = data_lt.contingency_table()
wti_lt = np.sum(c_table_lt,axis=1)/np.sum(c_table_lt)
data_lt.observed_frequency_confidence()

c_table_ut = data_ut.contingency_table()
wti_ut = np.sum(c_table_ut,axis=1)/np.sum(c_table_ut)
data_ut.observed_frequency_confidence()

# Other elements for plot
xd = yd = [0,1]
q = 1/3   # tercile
clim_x = clim_y = [q,q]
sk_line = [q/2,(1-q)/2+q]

# Plot
fig = pl.figure(figsize=(7,5))
pl.plot(xd,yd,color='black',linestyle=':',linewidth=0.5)
pl.plot(xd,clim_y,color='black',linestyle=':',linewidth=0.5)
pl.plot(clim_x,yd,color='black',linestyle=':',linewidth=0.5)
pl.plot(xd,sk_line,color='black',linestyle='--',linewidth=0.5)
pl.fill_between(xd,xd,sk_line,facecolor='grey',alpha=0.2)
pl.fill_betweenx(yd,yd,clim_x,facecolor='grey',alpha=0.2)
pl.scatter(data_lt.bins,data_lt.oi,s=wti_lt*10000,color='deepskyblue',marker='o',alpha=0.5,edgecolors='none')
pl.plot(data_lt.bins,data_lt.oi,color='deepskyblue',linestyle='-',linewidth=0.8, label="lower quartile")
pl.errorbar(data_lt.bins,data_lt.oi,yerr=[data_lt.oi - data_lt.ci_low, data_lt.ci_upp - data_lt.oi],ecolor='deepskyblue',elinewidth=0.8,alpha=0.5)
pl.scatter(data_ut.bins,data_ut.oi,s=wti_ut*10000,color='orange',marker='o',alpha=0.5,edgecolors='none')
pl.plot(data_ut.bins,data_ut.oi,color='orange',linestyle='-',linewidth=0.8, label="upper quartile")
pl.errorbar(data_ut.bins,data_ut.oi,yerr=[data_ut.oi - data_ut.ci_low, data_ut.ci_upp - data_ut.oi],ecolor='orange',elinewidth=0.8,alpha=0.5)
pl.ylim(0.0,1.0)
pl.xlim(0.0,1.0)
pl.legend()
pl.ylabel('Observed frequency \np(o|y)',fontsize=11)
pl.xlabel('Forecast probability \ny',fontsize=11)
pl.title("(underconfident model)")
pl.tight_layout()
pl.show()
```

###### Output

![png](example2.png)

