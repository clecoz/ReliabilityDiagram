# Documentation  

Project description --> describe what the project does

_References_:

[1] 

[2] 

[3] 

## _Installation:_

```sh
pip install PackageName
```

## _Parameters:_

**observation**: numpy.ndarray

Timeseries of observation/truth (1D).

**forecast**: numpy.ndarray

Forecast array (2D) with first dimension equal to the dimension of observation, and second dimension equal to the ensemble size.
    
**climatology**: numpy.ndarray

Climatological array (2D) with first dimension equal to the dimension of observation, and second dimension equal to the number of years considered in climatology.

**event_lbound**: int or float

The lower bound for the event considered. 

E.g. 1: If the event considered is lower tercile, then event_lbound value is 0. 

E.g. 2: If the event considered is upper tercile, then event_lbound value is 2/3. 

_NOTE_: The value should be in the range of 0 to 1.

**event_ubound**: int or float

The upper bound for the event considered.

E.g. 1: If the event considered is lower tercile, then event_ubound value is 1/3.

E.g. 2: If the event considered is upper tercile, then event_ubound value is 1. 

_NOTE_: The value should be in the range of 0 to 1.
            
**closed_ends**: str, optional

The bounds (upper and/or lower) to include in the event formulation. Options: 'left', 'right', 'none', 'both'. 

E.g. 1: If closed_ends = 'left', then the event becomes event_lbound <= event < event_ubound. 

E.g. 2: If closed_ends = 'both', then the event becomes event_lbound <= event <= event_ubound.

_NOTE_: The default value is 'both'. The value is case sensitive.
            
**nbins**: int, optional

Number of bins to stratify the forecasts into. The default is 5.

_NOTE_: The bins are of equal width.
            
**weights**: numpy.ndarray, optional

The weights for the forecast data. It should have the same shape as the forecast data.


## _Method(s):_

**contingency_table()**:

_Returns_:


**confidence_intervals()**:

_Returns_:


**forecast_attributes()**:

_Returns_:


**plot_diagram()**:

_Returns_:


## _Demonstration:_

```python
import ReliabilityDiagram as rd
import numpy as np
import matplotlib.pyplot as pl
```

### Example - 1:
* Create case data
```python
>>> nobs = 5000   # number of events
>>> nclim = 30    # number of years considered in climatology
>>> nfc = 51      # ensemble size of the forecasts

clima = np.random.normal(loc=0,scale=10,size=(nobs,nclim))   # climatology (follows the same normal distribution for all events)
obs = np.random.normal(loc=0,scale=10,size=(nobs))           # observations drawn from the same distribution as climatology
fcast = np.random.normal(loc=obs+np.random.normal(loc=0,scale=3,size=(nobs)) ,scale=5,size=(nfc,nobs)).T   # forecasts (also generated by a normal distribution 
                                                                                                           # s.t. ensemble mean = observations + noise)
```
* Compute contingency table and forecast attributes
```python
data = rd.ReliabilityDiagram(obs,fcast,clima,0,1/3,closed_ends='both',nbins=10)  # example for lower tercile 
```

```python
c_table = data.contingency_table()    
c_table
```

    array([[   9., 2090.],
           [  13.,  376.],
           [  44.,  230.],
           [  67.,  171.],
           [  99.,  134.],
           [  97.,   95.],
           [ 162.,   59.],
           [ 171.,   49.],
           [ 250.,   24.],
           [ 855.,    5.]])

    array([0,0])

```python
data.forecast_attributes()
```

    Reliability =  0.0004  | Resolution =  0.0165 
    (Reliability - Resolution) =  -0.0161
    




    (0.0003747137644693697, 0.01645615776446937)

* Plot reliability diagram


```python
# Elements for plot
xd = yd = [0,1]
q = data.ub - data.lb
clim_x = clim_y = [q,q]
sk_line = [q/2,(1-q)/2+q]
```


```python
# Calculate observed frequency and corresponding confidence interval
data.observed_frequency_confidence()
```




    (array([0.00428776, 0.03341902, 0.16058394, 0.28151261, 0.4248927 ,
            0.50520833, 0.73303167, 0.77727273, 0.91240876, 0.99418605]),
     array([0.00149249, 0.0155587 , 0.11711165, 0.22437552, 0.36142041,
            0.43448806, 0.67470823, 0.72229204, 0.87893551, 0.98910482]),
     array([0.00708303, 0.05127935, 0.20405623, 0.33864969, 0.488365  ,
            0.5759286 , 0.79135512, 0.83225341, 0.94588201, 0.99926727]))




```python
# Calculate weight of each forecast probability bins
wti = np.sum(c_table,axis=1)/np.sum(c_table)            # number of forecasts yi / total number of forecasts
```


```python
# Plot
fig = pl.figure(figsize=(7,5))
pl.plot(xd,yd,color='black',linestyle=':',linewidth=0.5)
pl.plot(xd,clim_y,color='black',linestyle=':',linewidth=0.5)
pl.plot(clim_x,yd,color='black',linestyle=':',linewidth=0.5)
pl.plot(xd,sk_line,color='black',linestyle='--',linewidth=0.5)
pl.fill_between(xd,xd,sk_line,facecolor='grey',alpha=0.2)
pl.fill_betweenx(yd,yd,clim_x,facecolor='grey',alpha=0.2)
pl.scatter(data.bins,data.oi,s=wti*10000,color='deepskyblue',marker='o',alpha=0.5,edgecolors='none')
pl.plot(data.bins,data.oi,color='deepskyblue',linestyle='-',linewidth=0.8)
pl.errorbar(data.bins,data.oi,yerr=[data.oi - data.ci_low, data.ci_upp - data.oi],ecolor='deepskyblue',elinewidth=0.8,alpha=0.5)
pl.ylim(0.0,1.0)
pl.xlim(0.0,1.0)
pl.ylabel('Observed frequency \np(o|y)',fontsize=11)
pl.xlabel('Forecast probability \ny',fontsize=11)
pl.title("Lower tercile (underconfident)")
pl.tight_layout()
```


    
![png](output_13_0.png)
    


### Example - 2:
```sh
In [2]: 
In [3]: 
Out[3]: 
In [4]: 
Out[4]: 
In [5]: 
Out[5]: 
```

